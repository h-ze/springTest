================================================================
CAP
CAP原则又称CAP定理，指的是在一个分布式系统中，一致性（Consistency）、可用性（Availability）、分区容错性（Partition tolerance）。CAP 原则指的是，这三个要素最多只能同时实现两点，不可能三者兼顾。

ACID
ACID，是指数据库管理系统（DBMS）在写入或更新资料的过程中，为保证事务（transaction）是正确可靠的，所必须具备的四个特性：原子性（atomicity，或称不可分割性）、一致性（consistency）、隔离性（isolation，又称独立性）、持久性

并发事务带来的问题:
在典型的应用程序中，多个事务并发运行，经常会操作相同的数据来完成各自的任务（多个用户对同一数据进行操作）。并发虽然是必须的，但可能会导致以下的问题。
    脏读（Dirty read）: 当一个事务正在访问数据并且对数据进行了修改，而这种修改还没有提交到数据库中，这时
另外一个事务也访问了这个数据，然后使用了这个数据。因为这个数据是还没有提交的数据，那么另外一个事务读到的这个
数据是“脏数据”，依据“脏数据”所做的操作可能是不正确的。
    丢失修改（Lost to modify）: 指在一个事务读取一个数据时，另外一个事务也访问了该数据，那么
在第一个事务中修改了这个数据后，第二个事务也修改了这个数据。这样第一个事务内的修改结果就被
丢失，因此称为丢失修。 例如：事务1读取某表中的数据A=20，事务2也读取A=20，事务1修改A=A-1，
事务2也修改A=A-1，最终结果A=19，事务1的修改被丢失。
    不可重复读（Unrepeatableread）: 指在一个事务内多次读同一数据。在这个事务还没有结束时，另
一个事务也访问该数据。那么，在第一个事务中的两次读数据之间，由于第二个事务的修改导致第一个
事务两次读取的数据可能不太一样。这就发生了在一个事务内两次读到的数据是不一样的情况，因此称
为不可重复读。
    幻读（Phantom read）: 幻读与不可重复读类似。它发生在一个事务（T1）读取了几行数据，接着另
一个并发事务（T2）插入了一些数据时。在随后的查询中，第一个事务（T1）就会发现多了一些原本不
存在的记录，就好像发生了幻觉一样，所以称为幻读。

不可重复读和幻读区别：不可重复读的重点是修改比如多次读取一条记录发现其中某些列的值被修改，幻读的重点在于新增或者
删除比如多次读取一条记录发现记录增多或减少了


事务的ACID是通过InnoDB日志和锁来保证。事务的隔离性是通过数据库锁的机制实现的，持久性通过redo log（重做日志）
来实现，原子性和一致性通过Undo log（回撤日志）来实现。Undo Log的原理很简单，为了满足事务的原子性，在操作任何数
据之前，首先将数据备份到一个地方（这个存储数据备份的地方称为Undo Log）。然后进行数据的修改。如果出现了错误或者用
户执行了roll back语句，系统可以利用Undo Log中的备份将数据恢复到事务开始之前的状态。 和Undo Log相反，Redo Log记
录的是新数据的备份。在事务提交前，只要将RedoLog持久化即可，不需要将数据持久化。当系统崩溃时，虽然数据没有持久化，但
是RedoLog已经持久化。系统可以根据Redo Log的内容，将所有数据恢复到最新的状态。

数据库的详情参考 数据库隔离级别.md

================================================================

Eureka是spring cloud中的一个负责服务注册与发现的组件。遵循着CAP理论中的A(可用性)P(分区容错性)。

一个Eureka中分为eureka server和eureka client。其中eureka server是作为服务的注册与发现中心。eureka client既可以作为服务的生产者，又可以作为服务的消费者
对比zookeeper(zookeeper是一个cp系统)

Eureka是Netflix开发的服务发现框架，SpringCloud将它集成在自己的子项目
spring-cloud-netflix中，实现SpringCloud的服务发现功能。Eureka包含两个组件：
Eureka Server和Eureka Client。
Eureka Server提供服务注册服务，各个节点启动后，会在Eureka Server中进行注
册，这样EurekaServer中的服务注册表中将会存储所有可用服务节点的信息，服务节点
的信息可以在界面中直观的看到。
​ Eureka Client是一个java客户端，用于简化与Eureka Server的交互，客户端同时也
就别一个内置的、使用轮询(round-robin)负载算法的负载均衡器。在应用启动后，将会
向Eureka Server发送心跳,默认周期为30秒，如果Eureka Server在多个心跳周期内没有
接收到某个节点的心跳，Eureka Server将会从服务注册表中把这个服务节点移除(默认90
秒)。
Eureka Server之间通过复制的方式完成数据的同步，Eureka还提供了客户端缓存机
制，即使所有的Eureka Server都挂掉，客户端依然可以利用缓存中的信息消费其他服务
的API。综上，Eureka通过心跳检查、客户端缓存等机制，确保了系统的高可用性、灵活
性和可伸缩性。

在eureka中，实际上是不区分服务的消费者和服务生产者的，一个服务的消费者，同样也可以是一个服务的生产者。

================================================================

什么是restful风格
http协议具体内容

================================================================

工厂模式和策略模式的区别
工厂模式中只管生产实例，具体怎么使用工厂实例由调用方决定，策略模式是将生成实例的使用策略放在策略类中配置后才提供调用方使用。 工厂模式调用方可以直接调用工厂实例的方法属性等，策略模式不能直接调用实例的方法属性，需要在策略类中封装策略后调用。
例如 需要新加一个方法 工厂模式新加之后还需在调用方处调用一次 策略模式直接在策略类里写一个方法并且在策略类里直接调用

================================================================

接口幂等性
多次调用接口时都应该产生一样的效果或返回一样的结果（一般场景对比支付）
代码逻辑判断
例如加入一个orderId标识订单的唯一性 检测订单是否已经支付过
 使用token机制实现接口幂等性,通用性强的实现方法
   token机制实现步骤:
   \1. 生成全局唯一的token,token放到redis或jvm内存,token会在页面跳转时获取.存放到pageScope中,支付请求提交先获取token
   \2. 提交后后台校验token，执行提交逻辑,提交成功同时删除token，生成新的token更新redis ,这样当第一次提交后token更新了,页面再次提交携带的token是已删除的token后台验证会失败不让提交
   token特点：  要申请，一次有效性，可以限流 
   注意： redis要用删除操作来判断token，删除成功代表token校验通过，如果用select+delete来校验token，存在并发问题，不建议使用 
   
7个HTTP方法：GET/POST/PUT/DELETE/PATCH/HEAD/OPTIONS  
delete 不安全但幂等  
put 不安全但幂等  
post 不安全且不幂等  
get 安全且幂等  

=================================================================




