 1.  浮点数值不适用于无法接受舍入误差的金融计算中。 例如，命令 System.out.println
( 2.0-1.1 ) 将打印出 0.8999999999999999, 而不是人们想象的 0.9。这种舍入误差的主要
原因是浮点数值采用二进制系统表示， 而在二进制系统中无法精确地表示分数 1/10。 这
就好像十进制无法精确地表示分数 1/3就应该使用 BigDecima丨类
2.使用算术运算符 +、-、 *、/ 表示加、减、 乘、 除运算。 当参与 / 运算的两个
操作数都是整数时， 表示整数除法；否则， 表示浮点除法。 整数的求余操作（有时称为取模)
用 ％ 表示。 例如， 15/2 等于 7， 15%2 等于 1, 15.0/2 等于 7.50
3.主函数中String[]args是专门用来接收命令行参数的
4.习惯上常量名全大写 包名全小写 类名每个单词第一个字符都大写 变量名方法名第一个字母小写其他单词的首字母大写（驼峰命名法）
5.Math类中包含了各种各样的数学函数。在编写不同类别的程序时，可能需要的函数也不同。
6.如果虚拟机始终将相同的字符串共享， 就可以使用= 运算符检测是否相等。但实际上
只有字符串常量是共享的，而+ 或 substring 等操作产生的结果并不是共享的.
对于习惯使用 C++ 的 string 类的人来说， 在进行相等性检测的时候一定要特
别小心。C++ 的 string 类重载了 == 运算符以便检测字符串内容的相等性。 可惜 Java 没
有采用这种方式， 它的字符串“ 看起来、 感觉起来” 与数值一样， 但进行相等性测试时，
其操作方式又类似于指针。语言的设计者本应该像对 + 那样也进行特殊处理， 即重定义
=运算符。当然，每一种语言都会存在一些不太一致的地方。
C 程序员从不使用 = 对字符串进行比较， 而使用 strcmp 函数。Java 的 compareTo
方法与 strcmp 完全类似， 因此， 可以这样使用：
if (greeti ng.compareTo("Hel1oH) === 0} . . 
7.空串 "" 是长度为 0 的字符串.空串是一个 Java 对象， 有自己的串长度（0 ) 和内容（空）。不过，String 变量还可以存
放一个特殊的值， 名为null, 这表示目前没有任何对象与该变量关联
8.如果基本的整数和浮点数精度不能够满足需求， 那么可以使用jaVa.math 包中的两个
很有用的类：Biglnteger 和 BigDecimaL 这两个类可以处理包含任意长度数字序列的数值。
Biglnteger 类实现了任意精度的整数运算， BigDecimal 实现了任意精度的浮点数运算。
9.很多人错误地认为 Java 对象变量与 C++ 的引用类似。 然而， 在 C++ 中没有
空引用， 并且引用不能被赋值。 可以将 Java 的对象变量看作 C++ 的对象指针。 例如，
Date birthday; // Java
实际上
， 等同于
Date* birthday; // C++
一旦理解了这一点， 一切问题就迎刃而解了。 当然， 一个 Date* 指针只能通过调用
new 进行初始化。就这一点而言，C++与 Java 的语法几乎是一样的 >
Date* birthday = new Date(); // C++
如果把一个变量的值賦给另一个变量， 两个变量就指向同一个日期， 即它们是同一
个对象的指针。 在 Java 中的 null 引用对应 C++ 中的 NULL 指针。
所有的 Java 对象都存储在堆中。 当一个对象包含另一个对象变量时， 这个变量依然
包含着指向另一个堆对象的指针。
在 C++ 中， 指针十分令人头疼， 并常常导致程序错误。 稍不小心就会创建一个错误
的指针， 或者造成内存溢出。 在 Java 语言中， 这些问题都不复存在。 如果使用一个没有
初始化的指针， 运行系统将会产生一个运行时错误， 而不是生成一个随机的结果， 同时，
不必担心内存管理问题， 垃圾收集器将会处理相关的事宜。
C++ 确实做了很大的努力
， 它通过拷贝型构造器和复制操作符来实现对象的自动拷
贝。 例如，一个链表（ linked list ) 拷贝的结果将会得到一个新链表， 其内容与原始链表
相同
， 但却是一组独立的链接。这使得将同样的拷贝行为内置在类中成为可能。 在 Java
中， 必须使用 clone 方法获得对象的完整拷贝 ?
10.== 运算符也可以应用于对象包装器对象， 只不过检测的是对象是
否指向同一个存储区域（对象包装器对象为Integer等基本类型的包装类）
11.有的时候一个类的对象是有限且固定的，这种情况下我们使用枚举类就比较方便
枚举类更加直观，类型安全。使用常量会有以下几个缺陷：
1. 类型不安全。若一个方法中要求传入季节这个参数，用常量的话，形参就是int类型，开发者传入任意类型的int类型值就行，但是如果是枚举类型的话，就只能传入枚举类中包含的对象。
2. 没有命名空间。开发者要在命名的时候以SEASON_开头，这样另外一个开发者再看这段代码的时候，才知道这四个常量分别代表季节。
12. 反射机制可以用来：
?在运行时分析类的能力。
?在运行时查看对象， 例如， 编写一个 toString 方法供所有类使用。
?实现通用的数组操作代码。
?利用 Method 对象， 这个对象很像中的函数指针。
13.虽然在接口中不能包含实例域或静态方法，但却可以包含常量。
与接口中的方法都自动地被设置为 public(不过，在实现接口时，必须把方法声明为public；否则，编译器将认为这个方法的访问属性是包可见性，即类的默认访问属性，之后，编译器就会给出视图提供更弱的访问权限的警告信息)
—样， 接口中的域将被自动设为 public static final
14. 为什么 Java 程
序设计语言还要不辞辛苦地引入接口概念？ 为什么不将 Comparable 直接设计成如下所示的
抽象类。
abstract class Comparable // why not?
{
public abstract int compareTo(Object other);
}
然后，Employee 类再直接扩展这个抽象类， 并提供 compareTo 方法的实现：
class Employee extends Comparable // why not?
{
public int compareTo(Object other) { . . . }
}
非常遗憾， 使用抽象类表示通用属性存在这样一个问题： 每个类只能扩展于一个类。假
设 Employee 类已经扩展于一个类， 例如 Person, 它就不能再像下面这样扩展第二个类了：
class Employee extends Person, Comparable // Error
有些程序设计语言允许一个类有多个超类， 例如 C++。我们将此特性称为多重继承
( multiple inheritance。) 而 Java 的设计者选择了不支持多继承，其主要原因是多继承会让语言
本身变得非常复杂（如同 C++，) 效率也会降低 （如同 Eiffel。)
实际上， 接口可以提供多重继承的大多数好处，同时还能避免多重继承的复杂性和低效性。
15.到目前为止，在 Java 中传递一个代码段并不容易， 不能直接传递代码段 _ Java 是一种面
向对象语言， 所以必须构造一个对象，这个对象的类需要有一个方法能包含所需的代码=
在其他语言中，可以直接处理代码块。Java 设计者很长时间以来一直拒绝增加这个特性。
毕竟，Java 的强大之处就在于其简单性和一致性。 如果只要一个特性能够让代码稍简洁一些，
就把这个特性增加到语言中， 这个语言很快就会变得一团糟，无法管理。 不过， 在另外那些
语言中，并不只是创建线程或注册按钮点击事件处理器更容易；它们的大部分 API 都更简单、
更一致而且更强大。在 Java 中， 也可以编写类似的 AP丨利用类对象实现特定的功能，不过这
种 API 使用可能很不方便。
就现在来说，问题已经不是是否增强 Java 来支持函数式编程， 而是要如何做到这一点。
16.JDK8及以后，允许我们在接口中定义static方法和default方法。

    public interface JDK8Interface {  
    
        // static修饰符定义静态方法  
        static void staticMethod() {  
            System.out.println("接口中的静态方法");  
        }  
          
        // default修饰符定义默认方法  
        default void defaultMethod() {  
            System.out.println("接口中的默认方法");  
        }  
    }  
17.Java 是一种强类型语言 ,lambda 表达式就是一个代码块， 以及必须传人
代码的变量规范。对于只有一个抽象方法的接口， 需要这种接口的对象时， 就可以提供一个 lambda 表达
式。这种接口称为函数式接口 （functional interface )。
18 在 Java 中， 利用关键字 final 指示常量，关键字 final 表示这个变量只能被赋值一次。一旦被赋值之后， 就不能够再更改了。习惯上,
常量名使用全大写。常量是final类型的
19.lambda 表达式有 3个部分：
1 ) 一个代码块；
2 ) 参数;
3 ) 自由变量的值， 这是指非参数而且不在代码中定义的变量。
20.lambda 表达式可以捕获外围作用域中变量的值。 在 Java 中， 要确保所捕获
的值是明确定义的，这里有一个重要的限制。在 lambda 表达式中， 只能引用值不会改变的
变量。例如， 下面的做法是不合法的：
public static void countDown(int start, int delay)
{
ActionListener listener = event ->
{
start ; // Error: Can't mutate captured variable
System.out.println(start);
}；
new Timer(del ay, listener) ,start();
}
之所以有这个限制是有原因的。 如果在 lambda 表达式中改变变量， 并发执行多个动作
时就会不安全。对于目前为止我们看到的动作不会发生这种情况，不过一般来讲，这确实是
一个严重的问题。
这里有一条规则：lambda 表达式中捕获的变量必须实际上是最终变量 ( effectivelyfinal)。
实际上的最终变量是指， 这个变量初始化之后就不会再为它赋新值。在这里，text 总是指示
同一个 String 对象，所以捕获这个变量是合法的。
21.使用 lambda 表达式的重点是延迟执行 deferred execution ) 毕竟， 如果想耍立即执行代
码，完全可以直接执行， 而无需把它包装在一个lambda 表达式中。之所以希望以后再执行
代码， 这有很多原因， 如：
?在一个单独的线程中运行代码；
?多次运行代码；
?在算法的适当位置运行代码 （例如， 排序中的比较操作；)
?发生某种情况时执行代码 （如， 点击了一个按钮， 数据到达， 等等；)
?只在必要时才运行代码。
22. 如果设计你自己的接口，其中只有一个抽象方法，可以用@FunctionalInterface 注
解来标记这个接口。 这样做有两个优点。 如果你无意中增加了另一个非抽象方法， 编译
器会产生一个错误消息。 另外 javadoc 页里会指出你的接口是一个函数式接口。
并不是必须使用注解根据定义， 任何有一个抽象方法的接口都是函数式接口。不
过使用 @FunctionalInterface 注解确实是一个很好的做法。
23.内部类（ inner class ) 是定义在另一个类中的类。为什么需要使用内部类呢？ 其主要原因
有以下三点：
?内部类方法可以访问该类定义所在的作用域中的数据， 包括私有的数据。
?内部类可以对同一个包中的其他类隐藏起来。
?当想要定义一个回调函数且不想编写大量代码时，使用匿名 （anonymous) 内部类比较
便捷
24. &&和&都是表示与，区别是&&只要第一个条件不满足，后面条件就不再判断。而&要对所有的条件都进行判断。
 ||和|都是表示“或”，区别是||只要满足第一个条件，后面的条件就不再判断，而|要对所有的条件进行判断。

25.对象包装器类是不可变的，即一旦构造了包装器，就不
允许更改包装在其中的值。同时， 对象包装器类还是 final , 因此不能定义它们的子类。

假设想定义一个整型数组列表。而尖括号中的类型参数不允许是基本类型，也就是说，
不允许写成 ArrayList<int>。这里就用到了 Integer 对象包装器类。 我们可以声明一个 Integer
对象的数组列表。
ArrayList<Integer> list = new ArrayList<>()；
26.由于每个值分别包装在对象中， 所以 ArrayList<lnteger> 的效率远远低于 int[ ] 数
组。 因此， 应该用它构造小型集合，其原因是此时程序员操作的方便性要比执行效率更
加重要
有一个很有用的特性， 从而更加便于添加 int 类型的元素到 ArrayLisKlntegeP
中。下面这个调用
list.add(3);
将自动地变换成
list.add(Integer.value0f(3));
这种变换被称为自动装箱（autoboxing。)
27.能够分析类能力的程序称为反射（reflective )。反射机制的功能极其强大，在下面可以看
到， 反射机制可以用来：
?在运行时分析类的能力。
?在运行时查看对象， 例如， 编写一个 toString 方法供所有类使用。
?实现通用的数组操作代码。
?利用 Method 对象， 这个对象很像中的函数指针。
反射是一种功能强大且复杂的机制。 